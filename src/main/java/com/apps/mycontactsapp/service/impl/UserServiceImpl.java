package com.apps.mycontactsapp.service.impl;

import com.apps.mycontactsapp.exceptions.ValidationException;
import com.apps.mycontactsapp.model.User;
import com.apps.mycontactsapp.model.UserType;
import com.apps.mycontactsapp.repository.UserRepository;
import com.apps.mycontactsapp.factory.UserFactory;
import com.apps.mycontactsapp.service.UserService;

/**
 * Implementation of the {@link UserService} interface.
 *
 * This service handles the core business logic for user registration, including
 * input validation,
 * user type handling, and persistence coordination.
 */
public class UserServiceImpl implements UserService {

    private final UserRepository userRepository;
    private com.apps.mycontactsapp.service.ContactService contactService;

    /**
     * Constructs a new UserServiceImpl with the required repository dependency.
     *
     * This constructor supports Dependency Injection (DI) as per the Inversion of
     * Control (IoC) principle.
     *
     * @param userRepository the repository for user data persistence.
     */
    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void setContactService(com.apps.mycontactsapp.service.ContactService contactService) {
        this.contactService = contactService;
    }

    /**
     * Registers a new user based on the provided details.
     *
     * Design Patterns:
     * - Factory Pattern: Uses {@link UserFactory} for creating concrete
     * {@link User} instances
     * (e.g., FreeUser, PremiumUser) based on the {@code userType} string.
     * This encapsulates the object creation logic and promotes loose coupling.
     * - Builder Pattern: The {@link UserFactory} internally uses the
     * Builder Pattern (via {@code User.UserBuilder})
     * to construct complex user objects step-by-step, ensuring mandatory fields are
     * set and validation rules are applied.
     *
     *
     * @param name        the name of the user.
     * @param email       the email address (must be unique).
     * @param password    the password (will be validated and hashed).
     * @param userTypeStr the string representation of the {@link UserType} (e.g.,
     *                    "FREE", "PREMIUM").
     * @throws ValidationException if the email already exists, the user type is
     *                             invalid, or password validation fails.
     */
    @Override
    public void registerUser(String name, String email, String password, String userTypeStr)
            throws ValidationException {
        // 1. Check if user already exists
        if (userRepository.existsByEmail(email)) {
            throw new ValidationException("User with email " + email + " already exists");
        }

        // 2. Parse UserType
        UserType userType;
        try {
            userType = UserType.valueOf(userTypeStr.toUpperCase());
        } catch (IllegalArgumentException | NullPointerException e) {
            throw new ValidationException("Invalid user type: " + userTypeStr);
        }

        // 3. Create User using Factory
        // Note: ID is null for new user, to be generated by repository/DB
        User newUser = UserFactory.createUser(userType, null, name, email, password);

        // 4. Save User
        userRepository.save(newUser);
    }

    /**
     * Retrieves all users.
     * Enforces Access Control: only ADMIN can execute this.
     *
     * @param requester the user requesting the list.
     * @return list of all users.
     * @throws ValidationException if requester is not ADMIN.
     */
    @Override
    public java.util.List<User> getAllUsers(User requester) throws ValidationException {
        if (requester == null || requester.getUserType() != UserType.ADMIN) {
            throw new ValidationException("Access Denied: Only Admin can view all users.");
        }
        return userRepository.findAll();
    }

    /**
     * Deletes a user by email (Admin operation).
     * Enforces Access Control: only ADMIN can execute this.
     *
     * @param requester   the user requesting deletion.
     * @param targetEmail the email of the target user.
     * @throws ValidationException if requester is not ADMIN or user not found.
     */
    @Override
    public void deleteUser(User requester, String targetEmail) throws ValidationException {
        if (requester == null || requester.getUserType() != UserType.ADMIN) {
            throw new ValidationException("Access Denied: Only Admin can delete other users.");
        }

        java.util.Optional<User> targetUserOpt = userRepository.findByEmail(targetEmail);
        if (targetUserOpt.isEmpty()) {
            throw new ValidationException("User not found: " + targetEmail);
        }

        deleteUser(targetUserOpt.get());
    }

    /**
     * Deletes a user and cascades the deletion to their contacts.
     * - First, deletes all contacts owned by the user.
     * - Second, deletes the user record itself.
     *
     * @param user the user to delete.
     */
    @Override
    public void deleteUser(User user) {
        if (user != null) {
            // 1. Cascade Delete Contacts
            if (contactService != null) {
                contactService.deleteAllContactsForUser(user.getId());
            }
            // 2. Delete User
            userRepository.delete(user);
        }
    }
}
